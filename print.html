<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Adam P. Regasz-Rethy&#x27;s Writings</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="mdbook.html">About this book</a></li><li class="chapter-item expanded "><a href="jd.html"><strong aria-hidden="true">1.</strong> A small ZSH script to replace autojump</a></li><li class="chapter-item expanded "><a href="colorscheme.html"><strong aria-hidden="true">2.</strong> Keeping Neovim and Kitty Terminal Colorschemes Consistent and Persistent</a></li><li class="chapter-item expanded "><a href="write_a_plugin_manager.html"><strong aria-hidden="true">3.</strong> Write Your Own Plugin Manager With A Focus On Ergonomics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="backpack_lua.html"><strong aria-hidden="true">3.1.</strong> Final Source Code</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Adam P. Regasz-Rethy&#x27;s Writings</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="about-this-book"><a class="header" href="#about-this-book">About this Book</a></h1>
<p>I've started using <a href="https://github.com/rust-lang/mdBook">mdBook</a> as a way to get better at writing and force myself to have a better understanding of what I'm working on. Hopefully this will help my future self when I need a reference, or potentially someone else.</p>
<p>In terms of mdBook itself, the best resource I've found is the guide book built with mdBook itself found at https://rust-lang.github.io/mdBook.</p>
<h2 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h2>
<p>Create a book with</p>
<pre><code class="language-sh">cargo install mdbook
mkdir book
cd book
mdbook init
</code></pre>
<p>The structure is found in <code>src/SUMMARY.md</code> and supports limited markdown syntax:</p>
<pre><code class="language-markdown"># This title is ignored
[Non-numered top-level section](path.md)
# Unclickable top-level title
- [Numered chapter title](path2.md)
    - [Nested sub-chapters](path3.md)
[Non-numered top-level section](path.md)
</code></pre>
<p>The contents files support normal markdown.</p>
<h2 id="deploy-to-github-pages"><a class="header" href="#deploy-to-github-pages">Deploy to GitHub Pages</a></h2>
<p>Add a <code>.github/workflows/gh-pages.yml</code> file with the contents:</p>
<pre><code class="language-yaml">name: github pages

on:
  push:
    branches:
      - master

jobs:
  deploy:
    runs-on: ubuntu-18.04
    steps:
      - uses: actions/checkout@v2

      - name: Setup mdBook
        uses: peaceiris/actions-mdbook@v1
        with:
          mdbook-version: 'latest'

      - run: mdbook build

      - name: Deploy
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./book
</code></pre>
<p>Go to <code>https://github.com/{username}/{repo}/settings/pages</code> and ensure the source branch is <code>gh-pages</code>.</p>
<p>I had to wait some time for it to deploy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-small-zsh-script-to-replace-autojump"><a class="header" href="#a-small-zsh-script-to-replace-autojump">A small ZSH script to replace autojump</a></h1>
<p>Add this to a <code>~/.zshrc</code> and ensure you have <a href="https://github.com/jhawthorn/fzy">fzy</a> installed.</p>
<p>When you type <code>jd </code> (<code>jd</code> followed by a space without pressing enter), fzy will pop open and let you change your <code>$PWD</code> to a previously visited directory. For details, just read the comments in the code snippet.</p>
<p><strong>Note</strong>: To change the keybinding, modify the <code>$JUMPDIR_KEYBIND</code> variable.</p>
<pre><code class="language-zsh">JUMPDIR_KEYBIND='jd '
# Setup some data a data file to store visited directories
mkdir -p &quot;$XDG_DATA_HOME/zshrc&quot;
JD_DATA_DIR=&quot;$XDG_DATA_HOME/zshrc/chpwd.txt&quot;
touch $JD_DATA_DIR
local tmp=$(mktemp)
cat $JD_DATA_DIR | while read dir ; do [[ -d $dir ]] &amp;&amp; echo $dir ; done &gt; $tmp
cat $tmp &gt; $JD_DATA_DIR
# Track visited directories
chpwd_functions+=(on_chpwd)
function on_chpwd {
    local tmp=$(mktemp)
    { echo $PWD ; cat $JD_DATA_DIR } | sort | uniq 1&gt; $tmp
    cat $tmp &gt; $JD_DATA_DIR
}
# zle widget function
function fzy_jd {
    # check if `jd ` was triggered in the middle of another command
    # e.g. $ aaaaaaajd 
    # If so, we manually input the `jd `
    if [[ ! -z $BUFFER ]]; then
        # Append `jd ` to the prompt
        BUFFER=$BUFFER$JUMPDIR_KEYBIND
        # move the cursor to the end of the line
        zle end-of-line
        return 0
    fi
    # ask the user to select a directory to jump to
    local dir=$({ echo $HOME ; cat $JD_DATA_DIR } | fzy)
    if [[ -z $dir ]]; then
        # no directory was selected, reset the prompt to what it was before
        zle reset-prompt
        return 0
    fi
    # Setup the command to change the directory
    BUFFER=&quot;cd $dir&quot;
    # Accepts the cd we setup above
    zle accept-line
    local ret=$?
    # force the prompt to redraw to mimic what would occur with a normal cd
    zle reset-prompt
    return $ret
}
# define the new widget function
zle -N fzy_jd
# bind the widget function to `jd `
bindkey $JUMPDIR_KEYBIND fzy_jd
# a nicety so that executing just jd will mimic the behaviour of just executing
# cd, that is, change the pwd to $HOME
eval &quot;alias $(echo $JUMPDIR_KEYBIND|xargs)=cd&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="keeping-neovim-and-kitty-terminal-colorschemes-consistent-and-persistent"><a class="header" href="#keeping-neovim-and-kitty-terminal-colorschemes-consistent-and-persistent">Keeping Neovim and Kitty Terminal Colorschemes Consistent and Persistent</a></h1>
<p>Whether it's to give my editor a new coat of paint or to make it easier on the eyes for 3am programming, I change its colours all the time. In editors such as Visual Studio Code or Atom, this is a simple matter of choosing a theme from a fuzzy matched drop-down menu. However, in Neovim we have to edit the <code>init.lua</code> and restart the editor (or source the <code>init.lua</code>). On top of this, we then need to update our terminal's colours to match (or at least I like to keep them consistent). This is tedious and nowhere near as clean as VSCode.</p>
<p>This tutorial will create a similar experience to VSCode where you can select a colorscheme using a dropdown fuzzy finder, and this colorscheme will remain consistent in Neovim and Kitty even if you close them and reopen.</p>
<p><strong>Note</strong>: We will be using <a href="https://github.com/chriskempson/base16">base16</a> colours but you can swap these out for something else.</p>
<p>We will use a file, <code>$XDG_CONFIG_HOME/.base16_theme</code>, as the single source of truth for our current colours. It will contain a single line with the name of our current base16 colours. For example,</p>
<pre><code>base16-gruvbox-dark-hard
</code></pre>
<h2 id="kitty-terminal-setup"><a class="header" href="#kitty-terminal-setup">Kitty (Terminal) Setup</a></h2>
<p><strong>Note</strong>: These steps only work in <a href="https://sw.kovidgoyal.net/kitty/">kitty</a>.</p>
<ol>
<li>Download <a href="https://github.com/kdrag0n/base16-kitty">base16-kitty</a> to <code>$HOME</code></li>
<li>In a shell startup script (e.g. <code>~/.zshrc</code>), add <code>eval &quot;kitty @ set-colors -c $HOME/base16-kitty/colors/$(cat $XDG_CONFIG_HOME/.base16_theme).conf&quot;</code>. This will set the colours for the current terminal window and for newly created terminal windows.</li>
</ol>
<h2 id="neovim-setup"><a class="header" href="#neovim-setup">Neovim Setup</a></h2>
<ol>
<li>
<p>Install <a href="https://github.com/rrethy/nvim-base16">nvim-base16</a> plugin. You can use a different collection of colorschemes but this will match the themes in <a href="https://github.com/kdrag0n/base16-kitty">base16-kitty</a> we used above.</p>
</li>
<li>
<p>Create a function to update the colours for our current terminal window and current instance of Neovim. We'll also need to update our <code>$XDG_CONFIG_HOME/.base16_theme</code>.</p>
</li>
</ol>
<pre><code class="language-lua">-- this is our single source of truth created above
local base16_theme_fname = vim.fn.expand(vim.env.XDG_CONFIG_HOME..'/.base16_theme')
-- this function is the only way we should be setting our colorscheme
local function set_colorscheme(name)
    -- write our colorscheme back to our single source of truth
    vim.fn.writefile({name}, base16_theme_fname)
    -- set Neovim's colorscheme
    vim.cmd('colorscheme '..name)
    -- execute `kitty @ set-colors -c &lt;color&gt;` to change terminal window's
    -- colors and newly created terminal windows colors
    vim.loop.spawn('kitty', {
        args = {
            '@',
            'set-colors',
            '-c',
            string.format(vim.env.HOME..'/base16-kitty/colors/%s.conf', name)
        }
    }, nil)
end
</code></pre>
<ol start="3">
<li>Read <code>$XDG_CONFIG_HOME/.base16_theme</code> to determine our current colours to use for Neovim.</li>
</ol>
<pre><code class="language-lua">set_colorscheme(vim.fn.readfile(base16_theme_fname)[1])
</code></pre>
<ol start="4">
<li>
<p>Install <a href="https://github.com/nvim-telescope/telescope.nvim">telescope.nvim</a>. Other fuzzy pickers will work, but this code snippet is for this plugin.</p>
</li>
<li>
<p>Override the <code>colorschemes</code> picker in <code>telescope.nvim</code> to update our terminal colours too</p>
</li>
</ol>
<pre><code class="language-lua">nvim.nnoremap('&lt;leader&gt;c', function()
    -- get our base16 colorschemes
    local colors = vim.fn.getcompletion('base16', 'color')
    -- we're trying to mimic VSCode so we'll use dropdown theme
    local theme = require('telescope.themes').get_dropdown()
    -- create our picker
    require('telescope.pickers').new(theme, {
        prompt = 'Change Base16 Colorscheme',
        finder = require('telescope.finders').new_table {
            results = colors
        },
        sorter = require('telescope.config').values.generic_sorter(theme),
        attach_mappings = function(bufnr)
            -- change the colors upon selection
            telescope_actions.select_default:replace(function()
                set_colorscheme(action_state.get_selected_entry().value)
                telescope_actions.close(bufnr)
            end)
            telescope_action_set.shift_selection:enhance({
                -- change the colors upon scrolling
                post = function()
                    set_colorscheme(action_state.get_selected_entry().value)
                end
            })
            return true
        end
    }):find()
end)
</code></pre>
<h2 id="try-it-out"><a class="header" href="#try-it-out">Try it out</a></h2>
<p>Open up Neovim, and hit <code>&lt;leader&gt;c</code> (or whatever mapping you used) and search for a colorscheme. As you scroll through the available colorschemes Neovim should update and Kitty should remain consistant. If you close then open Neovim, the colorscheme will persist with manually changing anything else. Not only that, but you can close and open Kitty and both Kitty and Neovim will maintain the previously selected colorscheme.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="write-your-own-plugin-manager-with-a-focus-on-ergonomics"><a class="header" href="#write-your-own-plugin-manager-with-a-focus-on-ergonomics">Write Your Own Plugin Manager With A Focus On Ergonomics</a></h1>
<p><em>Note: This is written with Neovim in mind but the same concepts can be applied to Vim</em></p>
<p>I've been pretty dissatisfied with the state of plugin managers in Neovim. Almost all of them follow a similar flow of editing your <code>init.lua</code>/<code>init.vim</code>, running an install command, and restarting Neovim to have the plugin loaded and ready to use. If we compare that with VSCode, we click a button to install the extension, and it usually <em>just works</em> with the occasional need to restart the editor. It's a lot more streamlined in VSCode and not having to restart the editor or manually edit config files is much smoother. What's worse is this is all functionality that can be mimicked in Neovim with a clever use of <code>:h packages</code>.</p>
<p>At the end of this article we'll have a small plugin manager (~130 lines of Lua) that will let you install the plugin with a simple <code>:PackAdd https://github.com/RRethy/vim-illuminate</code> which will make it instantly available without the need for a restart and you won't need to touch your dotfiles. Removing the plugin will be as easy as deleting a line in the manifest (we'll get to this later).</p>
<p><em>Note: This code will not be put into it's own repo but you can still add it to your own dotfiles for use (I currently use it). I'm hoping that this style of plugin manager pushes new plugin managers to create a more ergonomic experience.</em></p>
<h2 id="high-level-overview"><a class="header" href="#high-level-overview">High-Level Overview</a></h2>
<p>As with most plugin managers nowadays, we will build on top of the <code>:help packages</code> feature. However, unlike other managers, we will not use the <code>start/</code> directory to store plugins since those are all sourced at startup, instead we will download all plugins into <code>opt/</code> and execute a <code>:packadd &lt;plugin&gt;</code> to load it dynamically without restarting Neovim. We will also have a separate file that we'll call a pack manifest which is where our plugins will be listed, this manifest will be read at startup and each plugin will be <code>:packadd!</code> so it gets sourced, this has the added benefit that deleting a plugin is just deleting a line in the manifest.</p>
<p><em>Note: Not all plugins can be dynamically loaded, just most of them.</em></p>
<h2 id="picking-a-name"><a class="header" href="#picking-a-name">Picking a Name</a></h2>
<p><em>TLDR: backpack.lua</em></p>
<p>Picking a name is always tough, should we aim for descriptiveness (like <code>nvim-treesitter-textobjects</code>) or attempt to confuse the user (like <code>wildfire.vim</code> or <code>vim-hexokinase</code>), that is the question. Personally, I prefer names with personalities which are at least somewhat indicative of their functionality. A tried a true method for this would be to take a word that is directly related (like <code>pack</code> since we're using <code>:h packages</code>) and search for superstrings of that word which also make sense (https://www.thefreedictionary.com/words-containing-pack). We'll use <code>backpack.lua</code> since it sounds good enough.</p>
<h2 id="entry-point"><a class="header" href="#entry-point">Entry Point</a></h2>
<p>Let's create a file <code>lua/backpack.lua</code> (in our dotfiles) which will hold all of our code.</p>
<p>The directory for our plugins will be <code>vim.fn.stdpath('data')..'/site/pack/backpack/opt/'</code> which should be recognized by <code>:h 'packpath'</code> but if it isn't then add a <code>vim.opt.packpath:append('~/.local/share/nvim/site')</code> to your <code>init.lua</code>.</p>
<p>As mentioned above we'll have a manifest to specify what plugins we are using, we'll place this at <code>vim.fn.stdpath('config')..'/packmanifest.lua'</code> inside our dotfiles. Our manifest is a Lua file that we will <code>dofile()</code> and looks like this:</p>
<pre><code class="language-lua">use { 'RRethy/nvim-treesitter-textsubjects' }
use {
    'RRethy/vim-hexokinase',
    post_update = { 'make' }
}
use { 'tpope/vim-fugitive' }
</code></pre>
<p><code>use</code> will be a global we define specifically for use in the manifest to declare a plugin so it gets loaded and we track it in case it should be updated later on.</p>
<p>We'll also want to declare 3 commands for later use: <code>:PackAdd</code> to add a plugin, <code>:PackUpdate</code> to update our plugins, <code>:PackEdit</code> to view/edit the manifest.</p>
<p>Putting this into code looks like the following:</p>
<pre><code class="language-lua">local M = {}

local opt = vim.fn.stdpath('data')..'/site/pack/backpack/opt/'
local manifest = vim.fn.stdpath('config')..'/packmanifest.lua'

function M.setup()
    vim.fn.mkdir(opt, 'p') -- make sure opt exists

    M.plugins = {}
    -- 'use' will be define only for use in the manifest
    _G.use = function(opts)
        local _, _, author, plugin = string.find(opts[1], '^([^ /]+)/([^ /]+)$')
        -- track the plugin so it can be updated later with :PackUpdate
        table.insert(M.plugins, {
            plugin = plugin,
            author = author,
            post_update = opts.post_update,
        })
        if vim.fn.isdirectory(opt..'/'..plugin) ~= 0 then
            -- adds the plugin to the end of :help 'runtimepath'
            -- this will be what makes the plugin sourced
            -- NOTE: :packadd! is not the same as :packadd
            vim.cmd('packadd! '..plugin)
        end
    end
    if vim.fn.filereadable(manifest) ~= 0 then
        dofile(manifest)
    end
    _G.use = nil

    -- these functions will be defined later, you can add a --bar too if you want to chain command usage
    vim.cmd [[ command! -nargs=1 PackAdd lua require('rrethy.backpack').pack_add(&lt;f-args&gt;) ]]
    vim.cmd [[ command! PackUpdate lua require('rrethy.backpack').pack_update() ]]
    vim.cmd [[ command! PackEdit lua require('rrethy.backpack').pack_edit() ]]
end
</code></pre>
<p>Then our <code>init.lua</code> will have:</p>
<pre><code class="language-lua">require('backpack').setup()
</code></pre>
<h2 id="packadd"><a class="header" href="#packadd">:PackAdd</a></h2>
<p>Before we add code to install a plugin, we'll need a few helpers to pull Git repos, clone Git repos, and parse a GitHub URL.</p>
<p>We'll start with parsing a GitHub URL. I'm a big fan of just copy pasting the URL (<code>&lt;cmd&gt;l&lt;cmd&gt;c</code> on OSX) after a <code>:PackAdd </code>, it's quite ergonomic compared to looking for installation instructions or copying the exact part of the URL.</p>
<pre><code class="language-lua">local function parse_url(url)
    -- regex capture the username and plugin name from the url
    local username, plugin = string.match(url, '^https://github.com/([^/]+)/([^/]+)$')
    if not username or not plugin then
        -- failed to parse, we can spit an error out here
        return
    end

    local git_url
    if username == 'your username here' then
        -- a nicety for plugins that you wrote, prefer ssh over https
        git_url = string.format('git@github.com:%s/%s.git', username, plugin)
    else
        git_url = string.format('https://github.com/%s/%s.git', username, plugin)
    end

    return git_url, username, plugin
end
</code></pre>
<p>Now we'll want functions to clone and pull Git repos which will be used by <code>:PackAdd</code> and <code>:PackUpdate</code></p>
<pre><code class="language-lua">local function git_pull(name, on_success)
    local dir = opt..name
    -- get the branch name, there might be a better way to do this
    local branch = vim.fn.system(&quot;git -C &quot;..dir..&quot; branch --show-current | tr -d '\n'&quot;)
    -- use Luv to execute an async `git pull` with a shallow fetch
    vim.loop.spawn('git', {
        args = { 'pull', 'origin', branch, '--update-shallow', '--ff-only', '--progress', '--rebase=false' },
        cwd = dir,
    }, vim.schedule_wrap(function(code)
            if code == 0 then
                on_success(name)
            else
                echoerr(name..' pulled unsuccessfully')
            end
        end))
end

local function git_clone(name, git_url, on_success)
    -- use Luv to execute an async `git clone` with a shallow clone
    vim.loop.spawn('git', {
        args = { 'clone', '--depth=1', git_url },
        cwd = opt,
    }, vim.schedule_wrap(function(code)
            if code == 0 then
                on_success(name)
            else
                echoerr(name..' cloned unsuccessfully')
            end
        end))
end
</code></pre>
<p>Now we can write our actual <code>:PackAdd</code> functionality:</p>
<pre><code class="language-lua">function M.pack_add(url)
    local git_url, author, plugin = parse_url(url)
    if not git_url then
        -- failed to parse url
        return
    end

    -- track the plugin in case of a :PackUpdate later
    table.insert(M.plugins, {
        plugin = plugin,
        author = author,
    })
    local on_success = function()
        -- if successful, try loading the plugin dynamically without restarting Neovim
        vim.cmd('packadd '..plugin)
    end
    if vim.fn.isdirectory(opt..plugin) ~= 0 then
        git_pull(plugin, on_success)
    else
        git_clone(plugin, git_url, on_success)
    end

    -- automatically add the plugin data to our manifest
    vim.fn.system(string.format('echo &quot;use { \'%s/%s\' }&quot; &gt;&gt; %s', author, plugin, manifest))
end
</code></pre>
<h2 id="packupdate"><a class="header" href="#packupdate">:PackUpdate</a></h2>
<p>Since we were tracking our plugins in <code>M.plugins</code>, we can now just clone/pull each of them.</p>
<pre><code class="language-lua">function M.pack_update()
    for _, data in ipairs(M.plugins) do
        local on_success = function(plugin)
            vim.cmd('packadd '..plugin)
        end
        if vim.fn.isdirectory(opt..data.plugin) ~= 0 then
            git_pull(data.plugin, on_success)
        else
            git_clone(data.plugin, git_clone, on_success)
        end
    end
end
</code></pre>
<h2 id="packedit"><a class="header" href="#packedit">:PackEdit</a></h2>
<p>Since the manifest is just a Lua file, we can just open it up in a new tab. Closing the manifest is as simple as <code>:bw</code>. While this may seem trivial, IMO it's enough.</p>
<pre><code class="language-lua">function M.pack_edit()
    vim.cmd('tabnew')
    vim.cmd('edit '..manifest)
end
</code></pre>
<h2 id="post-update-hooks"><a class="header" href="#post-update-hooks">Post-Update Hooks</a></h2>
<p>We were also tracking post-update hooks which is the only additional feature we'll be adding (see below for other feature that were intentionally omitted). This can take the form of a lua function callback or a table representing shell commands to run in the root of the plugin.</p>
<p>We'll add this in <code>M.pack_update</code> after we dynamically reload the plugin in the <code>on_success</code> callback.</p>
<pre><code class="language-lua">if data.post_update then
    -- plugin root directory
    local dir = opt..'/'..plugin
    if type(data.post_update) == 'function' then
        -- execute the function and pass it the plugin dir
        data.post_update(dir)
    elseif type(data.post_update) == 'table' then
        -- use Luv to run the shell command in the plugin dir
        vim.loop.spawn(data.post_update[1], { args = data.post_update.args, cwd = dir },
            vim.schedule_wrap(function(code)
                if code ~= 0 then
                    vim.api.nvim_err_writeln(string.format('Failed to run %s', vim.inspect(data.post_update)))
                end
            end))
    end
end
</code></pre>
<h3 id="what-we-left-out-and-why"><a class="header" href="#what-we-left-out-and-why">What We Left Out (And Why)</a></h3>
<ol>
<li>Lazy loading on filetype
<ul>
<li>This frustrates me to no end, this feature is redundant!!! I've seen far too many <code>Plug 'vim-ruby/vim-ruby', { 'for': 'ruby' }</code>, just look at the source code for the plugin, it already lazily loads for <code>ruby</code> or <code>eruby</code> filetypes. In fact, most plugins lazy load most of their code until it's actually used. The few plugins which don't are typically quite old or if the plugin author doesn't know about <code>ftplugin/</code> or <code>autoload/</code> (probably should look for another plugin in that case). On top of this, I don't think people know that this doesn't restrict the plugin to that filetype, once it gets loaded, it's there for all filetypes.</li>
</ul>
</li>
<li>Lazy loading on command
<ul>
<li>Same reason as above, most plugins are already lazy loaded. Before you lazy load on <code>:Foo</code>, take a look at it's definition to see if it's just calling out to an autoloaded function which hasn't been sourced, if so, then it's already lazy loaded. If a plugin is doing massive amounts of work at startup then it might be time to look for a better written plugin.</li>
</ul>
</li>
<li>Lua Rocks support
<ul>
<li>This would be nice to have but I hope this becomes part of Neovim rather than forcing plugin managers to add support for it.</li>
</ul>
</li>
<li>Rigorous Error Handling
<ul>
<li>I trimmed it off to reduce the complexity and size, simply writing errors to a log file is an easy way to add it back.</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><pre><code class="language-lua">local echoerr = vim.api.nvim_err_writeln

local M = {}

local opt = vim.fn.stdpath('data')..'/site/pack/backpack/opt/'
local manifest = vim.fn.stdpath('config')..'/packmanifest.lua'

local function parse_url(url)
    local username, plugin = string.match(url, '^https://github.com/([^/]+)/([^/]+)$')
    if not username or not plugin then
        return
    end

    local git_url
    if username == 'your GitHub username' then
        git_url = string.format('git@github.com:%s/%s.git', username, plugin)
    else
        git_url = string.format('https://github.com/%s/%s.git', username, plugin)
    end

    return git_url, username, plugin
end

local function git_pull(name, on_success)
    local dir = opt..name
    local branch = vim.fn.system(&quot;git -C &quot;..dir..&quot; branch --show-current | tr -d '\n'&quot;)
    vim.loop.spawn('git', {
        args = { 'pull', 'origin', branch, '--update-shallow', '--ff-only', '--progress', '--rebase=false' },
        cwd = dir,
    }, vim.schedule_wrap(function(code)
            if code == 0 then
                on_success(name)
            else
                echoerr(name..' pulled unsuccessfully')
            end
        end))
end

local function git_clone(name, git_url, on_success)
    vim.loop.spawn('git', {
        args = { 'clone', '--depth=1', git_url },
        cwd = opt,
    }, vim.schedule_wrap(function(code)
            if code == 0 then
                on_success(name)
            else
                echoerr(name..' cloned unsuccessfully')
            end
        end))
end

function M.setup()
    vim.fn.mkdir(opt, 'p')

    M.plugins = {}
    _G.use = function(opts)
        local _, _, author, plugin = string.find(opts[1], '^([^ /]+)/([^ /]+)$')
        table.insert(M.plugins, {
            plugin = plugin,
            author = author,
            post_update = opts.post_update,
        })
        if vim.fn.isdirectory(opt..'/'..plugin) ~= 0 then
            vim.cmd('packadd! '..plugin)
        end
    end
    if vim.fn.filereadable(manifest) ~= 0 then
        dofile(manifest)
    end
    _G.use = nil

    vim.cmd [[ command! -nargs=1 PackAdd lua require('rrethy.backpack').pack_add(&lt;f-args&gt;) ]]
    vim.cmd [[ command! PackUpdate lua require('rrethy.backpack').pack_update() ]]
    vim.cmd [[ command! PackEdit lua require('rrethy.backpack').pack_edit() ]]
end

function M.pack_add(url)
    local git_url, author, plugin = parse_url(url)
    if not git_url then
        return
    end

    table.insert(M.plugins, {
        plugin = plugin,
        author = author,
    })
    local on_success = function()
        vim.cmd('packadd '..plugin)
    end
    if vim.fn.isdirectory(opt..plugin) ~= 0 then
        git_pull(plugin, on_success)
    else
        git_clone(plugin, git_url, on_success)
    end

    vim.fn.system(string.format('echo &quot;use { \'%s/%s\' }&quot; &gt;&gt; %s', author, plugin, manifest))
end

function M.pack_update()
    for _, data in ipairs(M.plugins) do
        local on_success = function(plugin)
            vim.cmd('packadd '..plugin)
            if data.post_update then
                local dir = opt..'/'..plugin
                if type(data.post_update) == 'function' then
                    data.post_update(dir)
                elseif type(data.post_update) == 'table' then
                    vim.loop.spawn(data.post_update[1], { args = data.post_update.args, cwd = dir },
                        vim.schedule_wrap(function(code)
                            if code ~= 0 then
                                vim.api.nvim_err_writeln(string.format('Failed to run %s', vim.inspect(data.post_update)))
                            end
                        end))
                end
            end
        end
        if vim.fn.isdirectory(opt..data.plugin) ~= 0 then
            git_pull(data.plugin, on_success)
        else
            git_clone(data.plugin, git_clone, on_success)
        end
    end
end

function M.pack_edit()
    vim.cmd('tabnew')
    vim.cmd('edit '..manifest)
end

return M
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
                <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-198719381-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
