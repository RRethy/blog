<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Write Your Own Plugin Manager With A Focus On Ergonomics - Adam P. Regasz-Rethy&#x27;s Writings</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="mdbook.html">About this book</a></li><li class="chapter-item expanded "><a href="jd.html"><strong aria-hidden="true">1.</strong> A small ZSH script to replace autojump</a></li><li class="chapter-item expanded "><a href="colorscheme.html"><strong aria-hidden="true">2.</strong> Keeping Neovim and Kitty Terminal Colorschemes Consistent and Persistent</a></li><li class="chapter-item expanded "><a href="write_a_plugin_manager.html" class="active"><strong aria-hidden="true">3.</strong> Write Your Own Plugin Manager With A Focus On Ergonomics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="backpack_lua.html"><strong aria-hidden="true">3.1.</strong> Final Source Code</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Adam P. Regasz-Rethy&#x27;s Writings</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="write-your-own-plugin-manager-with-a-focus-on-ergonomics"><a class="header" href="#write-your-own-plugin-manager-with-a-focus-on-ergonomics">Write Your Own Plugin Manager With A Focus On Ergonomics</a></h1>
<p><em>Note: This is written with Neovim in mind but the same concepts can be applied to Vim</em></p>
<p>I've been pretty dissatisfied with the state of plugin managers in Neovim. Almost all of them follow a similar flow of editing your <code>init.lua</code>/<code>init.vim</code>, running an install command, and restarting Neovim to have the plugin loaded and ready to use. If we compare that with VSCode, we click a button to install the extension, and it usually <em>just works</em> with the occasional need to restart the editor. It's a lot more streamlined in VSCode and not having to restart the editor or manually edit config files is much smoother. What's worse is this is all functionality that can be mimicked in Neovim with a clever use of <code>:h packages</code>.</p>
<p>At the end of this article we'll have a small plugin manager (~130 lines of Lua) that will let you install the plugin with a simple <code>:PackAdd https://github.com/RRethy/vim-illuminate</code> which will make it instantly available without the need for a restart and you won't need to touch your dotfiles. Removing the plugin will be as easy as deleting a line in the manifest (we'll get to this later).</p>
<p><em>Note: This code will not be put into it's own repo but you can still add it to your own dotfiles for use (I currently use it). I'm hoping that this style of plugin manager pushes new plugin managers to create a more ergonomic experience.</em></p>
<h2 id="high-level-overview"><a class="header" href="#high-level-overview">High-Level Overview</a></h2>
<p>As with most plugin managers nowadays, we will build on top of the <code>:help packages</code> feature. However, unlike other managers, we will not use the <code>start/</code> directory to store plugins since those are all sourced at startup, instead we will download all plugins into <code>opt/</code> and execute a <code>:packadd &lt;plugin&gt;</code> to load it dynamically without restarting Neovim. We will also have a separate file that we'll call a pack manifest which is where our plugins will be listed, this manifest will be read at startup and each plugin will be <code>:packadd!</code> so it gets sourced, this has the added benefit that deleting a plugin is just deleting a line in the manifest.</p>
<p><em>Note: Not all plugins can be dynamically loaded, just most of them.</em></p>
<h2 id="picking-a-name"><a class="header" href="#picking-a-name">Picking a Name</a></h2>
<p><em>TLDR: backpack.lua</em></p>
<p>Picking a name is always tough, should we aim for descriptiveness (like <code>nvim-treesitter-textobjects</code>) or attempt to confuse the user (like <code>wildfire.vim</code> or <code>vim-hexokinase</code>), that is the question. Personally, I prefer names with personalities which are at least somewhat indicative of their functionality. A tried a true method for this would be to take a word that is directly related (like <code>pack</code> since we're using <code>:h packages</code>) and search for superstrings of that word which also make sense (https://www.thefreedictionary.com/words-containing-pack). We'll use <code>backpack.lua</code> since it sounds good enough.</p>
<h2 id="entry-point"><a class="header" href="#entry-point">Entry Point</a></h2>
<p>Let's create a file <code>lua/backpack.lua</code> (in our dotfiles) which will hold all of our code.</p>
<p>The directory for our plugins will be <code>vim.fn.stdpath('data')..'/site/pack/backpack/opt/'</code> which should be recognized by <code>:h 'packpath'</code> but if it isn't then add a <code>vim.opt.packpath:append('~/.local/share/nvim/site')</code> to your <code>init.lua</code>.</p>
<p>As mentioned above we'll have a manifest to specify what plugins we are using, we'll place this at <code>vim.fn.stdpath('config')..'/packmanifest.lua'</code> inside our dotfiles. Our manifest is a Lua file that we will <code>dofile()</code> and looks like this:</p>
<pre><code class="language-lua">use { 'RRethy/nvim-treesitter-textsubjects' }
use {
    'RRethy/vim-hexokinase',
    post_update = { 'make' }
}
use { 'tpope/vim-fugitive' }
</code></pre>
<p><code>use</code> will be a global we define specifically for use in the manifest to declare a plugin so it gets loaded and we track it in case it should be updated later on.</p>
<p>We'll also want to declare 3 commands for later use: <code>:PackAdd</code> to add a plugin, <code>:PackUpdate</code> to update our plugins, <code>:PackEdit</code> to view/edit the manifest.</p>
<p>Putting this into code looks like the following:</p>
<pre><code class="language-lua">local M = {}

local opt = vim.fn.stdpath('data')..'/site/pack/backpack/opt/'
local manifest = vim.fn.stdpath('config')..'/packmanifest.lua'

function M.setup()
    vim.fn.mkdir(opt, 'p') -- make sure opt exists

    M.plugins = {}
    -- 'use' will be define only for use in the manifest
    _G.use = function(opts)
        local _, _, author, plugin = string.find(opts[1], '^([^ /]+)/([^ /]+)$')
        -- track the plugin so it can be updated later with :PackUpdate
        table.insert(M.plugins, {
            plugin = plugin,
            author = author,
            post_update = opts.post_update,
        })
        if vim.fn.isdirectory(opt..'/'..plugin) ~= 0 then
            -- adds the plugin to the end of :help 'runtimepath'
            -- this will be what makes the plugin sourced
            -- NOTE: :packadd! is not the same as :packadd
            vim.cmd('packadd! '..plugin)
        end
    end
    if vim.fn.filereadable(manifest) ~= 0 then
        dofile(manifest)
    end
    _G.use = nil

    -- these functions will be defined later, you can add a --bar too if you want to chain command usage
    vim.cmd [[ command! -nargs=1 PackAdd lua require('rrethy.backpack').pack_add(&lt;f-args&gt;) ]]
    vim.cmd [[ command! PackUpdate lua require('rrethy.backpack').pack_update() ]]
    vim.cmd [[ command! PackEdit lua require('rrethy.backpack').pack_edit() ]]
end
</code></pre>
<p>Then our <code>init.lua</code> will have:</p>
<pre><code class="language-lua">require('backpack').setup()
</code></pre>
<h2 id="packadd"><a class="header" href="#packadd">:PackAdd</a></h2>
<p>Before we add code to install a plugin, we'll need a few helpers to pull Git repos, clone Git repos, and parse a GitHub URL.</p>
<p>We'll start with parsing a GitHub URL. I'm a big fan of just copy pasting the URL (<code>&lt;cmd&gt;l&lt;cmd&gt;c</code> on OSX) after a <code>:PackAdd </code>, it's quite ergonomic compared to looking for installation instructions or copying the exact part of the URL.</p>
<pre><code class="language-lua">local function parse_url(url)
    -- regex capture the username and plugin name from the url
    local username, plugin = string.match(url, '^https://github.com/([^/]+)/([^/]+)$')
    if not username or not plugin then
        -- failed to parse, we can spit an error out here
        return
    end

    local git_url
    if username == 'your username here' then
        -- a nicety for plugins that you wrote, prefer ssh over https
        git_url = string.format('git@github.com:%s/%s.git', username, plugin)
    else
        git_url = string.format('https://github.com/%s/%s.git', username, plugin)
    end

    return git_url, username, plugin
end
</code></pre>
<p>Now we'll want functions to clone and pull Git repos which will be used by <code>:PackAdd</code> and <code>:PackUpdate</code></p>
<pre><code class="language-lua">local function git_pull(name, on_success)
    local dir = opt..name
    -- get the branch name, there might be a better way to do this
    local branch = vim.fn.system(&quot;git -C &quot;..dir..&quot; branch --show-current | tr -d '\n'&quot;)
    -- use Luv to execute an async `git pull` with a shallow fetch
    vim.loop.spawn('git', {
        args = { 'pull', 'origin', branch, '--update-shallow', '--ff-only', '--progress', '--rebase=false' },
        cwd = dir,
    }, vim.schedule_wrap(function(code)
            if code == 0 then
                on_success(name)
            else
                echoerr(name..' pulled unsuccessfully')
            end
        end))
end

local function git_clone(name, git_url, on_success)
    -- use Luv to execute an async `git clone` with a shallow clone
    vim.loop.spawn('git', {
        args = { 'clone', '--depth=1', git_url },
        cwd = opt,
    }, vim.schedule_wrap(function(code)
            if code == 0 then
                on_success(name)
            else
                echoerr(name..' cloned unsuccessfully')
            end
        end))
end
</code></pre>
<p>Now we can write our actual <code>:PackAdd</code> functionality:</p>
<pre><code class="language-lua">function M.pack_add(url)
    local git_url, author, plugin = parse_url(url)
    if not git_url then
        -- failed to parse url
        return
    end

    -- track the plugin in case of a :PackUpdate later
    table.insert(M.plugins, {
        plugin = plugin,
        author = author,
    })
    local on_success = function()
        -- if successful, try loading the plugin dynamically without restarting Neovim
        vim.cmd('packadd '..plugin)
    end
    if vim.fn.isdirectory(opt..plugin) ~= 0 then
        git_pull(plugin, on_success)
    else
        git_clone(plugin, git_url, on_success)
    end

    -- automatically add the plugin data to our manifest
    vim.fn.system(string.format('echo &quot;use { \'%s/%s\' }&quot; &gt;&gt; %s', author, plugin, manifest))
end
</code></pre>
<h2 id="packupdate"><a class="header" href="#packupdate">:PackUpdate</a></h2>
<p>Since we were tracking our plugins in <code>M.plugins</code>, we can now just clone/pull each of them.</p>
<pre><code class="language-lua">function M.pack_update()
    for _, data in ipairs(M.plugins) do
        local on_success = function(plugin)
            vim.cmd('packadd '..plugin)
        end
        if vim.fn.isdirectory(opt..data.plugin) ~= 0 then
            git_pull(data.plugin, on_success)
        else
            git_clone(data.plugin, git_clone, on_success)
        end
    end
end
</code></pre>
<h2 id="packedit"><a class="header" href="#packedit">:PackEdit</a></h2>
<p>Since the manifest is just a Lua file, we can just open it up in a new tab. Closing the manifest is as simple as <code>:bw</code>. While this may seem trivial, IMO it's enough.</p>
<pre><code class="language-lua">function M.pack_edit()
    vim.cmd('tabnew')
    vim.cmd('edit '..manifest)
end
</code></pre>
<h2 id="post-update-hooks"><a class="header" href="#post-update-hooks">Post-Update Hooks</a></h2>
<p>We were also tracking post-update hooks which is the only additional feature we'll be adding (see below for other feature that were intentionally omitted). This can take the form of a lua function callback or a table representing shell commands to run in the root of the plugin.</p>
<pre><code class="language-lua">-- function M.pack_update()
--     for _, data in ipairs(M.plugins) do
--         local on_success = function(plugin)
--             vim.cmd('packadd '..plugin)
            if data.post_update then
                -- plugin root directory
                local dir = opt..'/'..plugin
                if type(data.post_update) == 'function' then
                    -- execute the function and pass it the plugin dir
                    data.post_update(dir)
                elseif type(data.post_update) == 'table' then
                    -- use Luv to run the shell command in the plugin dir
                    vim.loop.spawn(data.post_update[1], { args = data.post_update.args, cwd = dir },
                        vim.schedule_wrap(function(code)
                            if code ~= 0 then
                                vim.api.nvim_err_writeln(string.format('Failed to run %s', vim.inspect(data.post_update)))
                            end
                        end))
                end
            end
--         end
--         if vim.fn.isdirectory(opt..data.plugin) ~= 0 then
--             git_pull(data.plugin, on_success)
--         else
--             git_clone(data.plugin, git_clone, on_success)
--         end
--     end
-- end
</code></pre>
<h3 id="what-we-left-out-and-why"><a class="header" href="#what-we-left-out-and-why">What We Left Out (And Why)</a></h3>
<ol>
<li>Lazy loading on filetype
<ul>
<li>This frustrates me to no end, this feature is redundant!!! I've seen far too many <code>Plug 'vim-ruby/vim-ruby', { 'for': 'ruby' }</code>, just look at the source code for the plugin, it already lazily loads for <code>ruby</code> or <code>eruby</code> filetypes. In fact, most plugins lazy load most of their code until it's actually used. The few plugins which don't are typically quite old or if the plugin author doesn't know about <code>ftplugin/</code> or <code>autoload/</code> (probably should look for another plugin in that case). On top of this, I don't think people know that this doesn't restrict the plugin to that filetype, once it gets loaded, it's there for all filetypes.</li>
</ul>
</li>
<li>Lazy loading on command
<ul>
<li>Same reason as above, most plugins are already lazy loaded. Before you lazy load on <code>:Foo</code>, take a look at it's definition to see if it's just calling out to an autoloaded function which hasn't been sourced, if so, then it's already lazy loaded. If a plugin is doing massive amounts of work at startup then it might be time to look for a better written plugin.</li>
</ul>
</li>
<li>Lua Rocks support
<ul>
<li>This would be nice to have but I hope this becomes part of Neovim rather than forcing plugin managers to add support for it.</li>
</ul>
</li>
<li>Rigorous Error Handling
<ul>
<li>I trimmed it off to reduce the complexity and size, simply writing errors to a log file is an easy way to add it back.</li>
</ul>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="colorscheme.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="backpack_lua.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="colorscheme.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="backpack_lua.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
                <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-198719381-1', 'auto');
                ga('send', 'pageview');
            }
        </script>
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
